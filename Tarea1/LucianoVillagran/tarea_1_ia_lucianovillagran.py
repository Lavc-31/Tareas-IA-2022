# -*- coding: utf-8 -*-
"""Tarea-1-IA-LucianoVillagran.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bUU-GprRltpVnFGUk_E0rx00drbN-WNC

## **Pregunta 1**

El enunciado de esta pregunta pide aprender la estructura de la red bayesiana descrita en función del
dataset entregado y caracterizar los parámetros de dicha red, para posteriormente enunciar y efectuar tres consultas de inferencia sobre la red, así como también documentar la reorganización de los parámetros para cada uno de los casos tras la realización de las consultas.

Para llevar a cabo esto en primera instancia es necesario instalar ciertas librerías como puede observarse a continuación.
"""

!pip install -U bnlearn
!pip install -U matplotlib

"""Una vez instaladas las librerías corresponde importarlas al código, cabe destacar que se importan también librerías que ya se encontraban instaladas en el entorno de trabajo."""

import matplotlib as plt
import pandas as pd
import numpy as np
import pgmpy as pg
import bnlearn as bn

"""A continuación se lee el dataset y se muestran sus dimensiones, esto es logrado mediante el uso de la función *read_csv* presente en la librería **pandas**. Se puede observar que el dataset contiene un millón de filas y siete columnas."""

datos = pd.read_csv('dataset18.csv')
print(datos.shape)

"""Tras guardar en una variable el dataset leido es posible aprender la estructura base de la red bayesiana que se puede generar a partir de los datos. Esto se logra mediante el uso de la función *structure_learning.fit* presente en la librería **bnlearn**, luego mediante la función *plot* de la misma librería se procede a graficar esta estructura base."""

grafo = bn.structure_learning.fit(datos)
base = bn.plot(grafo)

"""Luego de aprender y graficar la estructura base de la red resulta conveniente listar los parámetros involucrados en los cálculos y sus posibles valores.
En este caso todos los parámetros son de naturaleza binaria, es decir, solo pueden tomar valores de 1 o 0. Dichos parámetros son los siguientes:

*   inflacion: en caso de existir toma valor 1
*   escasez: en caso de existir toma valor 1
*   guerra_ucrania: en caso de existir toma valor 1
*   no_confort: en caso de ser cierto toma valor 1
*   no_carne: en caso de ser cierto toma valor 1
*   precios_altos: en caso de existir toma valor 1
*   no_alcohol: en caso de ser cierto toma valor 1, podemos notar que este parámetro no forma parte de la estructura base de la red, esto se debe a que en el dataset entregado siempre toma valor 0, dada esta información se puede afirmar que siempre habrá alcohol, por lo que no es un parámetro que afecte a cálculos o inferencias.

Con estas definiciones en consideración ahora corresponde actualizar el modelo mediante el aprendizaje de los parámetros entregados en el dataset y según la importancia de las relaciones entre los distintos nodos del grafo generado. Para poder lograr esto se hace uso de la función *parameter_learning.fit* de la librería **bnlearn** y posteriormente se vuelve a usar la función *plot* para graficar la red bayesiana actualizada.
"""

actualizar_modelo = bn.parameter_learning.fit(grafo, datos)
red = bn.plot(actualizar_modelo, interactive=True, params_interactive={'notebook':True})

"""Finalmente se debe estudiar la red generada para entender que consultas sería conveniente realizar, una vez evaluado ese aspecto se debe usar la función *inference.fit* presente en la librería **bnlearn**.

Dada la naturaleza binaria de los parámetros del problema planteado resulta directo pensar en ciertas relaciones causa-efecto que sean candidatas a ser invertidas para transformarse en consultas de inferencia. Bajo esta lógica, se decidió realizar las siguientes consultas.


1.   ¿Cuál es la probabilidad de que no haya confort dado que no hay carne?
2.   ¿Cuál es la probabilidad de que exista escasez e inflación dado que no hay carne?
3.   ¿Cuál es la probabilidad de que exista inflación dado que no hay confort pero si hay carne?

Los resultados de estas consultas pueden verse a continuación.




"""

inferencia_1 = bn.inference.fit(actualizar_modelo, variables=['no_confort'], evidence={'no_carne':1})
inferencia_2 = bn.inference.fit(actualizar_modelo, variables=['escasez','inflacion'], evidence={'no_carne':1})
inferencia_3 = bn.inference.fit(actualizar_modelo, variables=['inflacion'], evidence={'no_confort':1, 'no_carne':0})

"""Como se puede observar en la sección anterior el programa calcula las probabilidades de las inferencias solicitadas, es asi como podemos notar las respuestas a las preguntas.

1.   La probabilidad de que no haya confort dado que no hay carne es de un 58.62%
2.   La probabilidad de que exista escasez e inflación dado que no hay carne es de un 73.7%, esto corresponde al caso en que ambos parámetros toman valor 1
3.   La probabilidad de que exista inflación dado que no hay confort pero si hay carne es de un 88.7%

Se puede notar además que para todos los casos planteados se elimina el nodo llamado *guerra_ucrania* o el nodo llamado *precios_altos*, ya que ambos nodos poseen el mismo número de conexiones y ambos ocupan una posición "central" en la red. Es mediante este tipo de eliminación que se cumplen los criterios de la independencia condicional dentro de la red bayesiana, los cuales luego derivan en cálculos más sencillos para las inferencias solicitadas.

## **Pregunta 2**

El enunciado de esta pregunta pide realizar RandomWalks de distintos tamaños sobre la matriz otorgada y generar gráficos de líneas que representen las probabilidades de escuchar una canción de alguno de los grupos mencionados en el enunciado.

Para llevar a cabo esto en primera instancia es necesario instalar una librería que facilitará el proceso, dicha instalación puede observarse a continuación.
"""

!pip install pyrandwalk

"""Tras haber realizado la instalación se debe proceder a importar las librerías necesarias para el desarrollo de la pregunta. Cabe destacar que se importan también librerías que ya se encontraban instaladas en el entorno de trabajo."""

from pyrandwalk import *
import numpy as np
import matplotlib.pyplot as plt

"""A continuación se procede a realizar cuatro RandomWalks de tamaño 10, 100, 1000  y 10000 respectivamente con la ayuda de las funciones *RandomWalk* y *run* presentes en la librería **pyrandwalk**. En primera instancia se configuran los parámetros correspondientes a los calculos de las probabilidades asociadas al problema, luego se escribe la matriz de transiciones T y el vector de estados para poder así realizar el RandomWalk y dentro de cada ciclo llevar a cabo los calculos asociados a los datos necesarios para graficar, este proceso se repite cuatro veces generando cuatro gráficos de linea distintos."""

c1=[]
c2=[]
c3=[]
c4=[]
c5=[]
c6=[]
c7=[]
c8=[]
c9=[]

cont1 = 0
cont2 = 0
cont3 = 0
cont4 = 0
cont5 = 0
cont6 = 0
cont7 = 0
cont8 = 0
cont9 = 0
T = np.array([[0.25, 0.06, 0.08, 0.15, 0.04, 0.02, 0.15, 0.15, 0.10], [0.15, 0.15, 0.10, 0.22, 0.01, 0.02, 0.15, 0.10, 0.10], [0.12, 0.00, 0.05, 0.24, 0.14, 0.04, 0.27, 0.07, 0.07], [0.05, 0.13, 0.05, 0.30, 0.10, 0.10, 0.22, 0.05, 0.00], [0.18, 0.20, 0.07, 0.20, 0.15, 0.05, 0.05, 0.05, 0.05], [0.20, 0.10, 0.20, 0.05, 0.05, 0.10, 0.02, 0.15, 0.13], [0.01, 0.05, 0.15, 0.14, 0.17, 0.10, 0.12, 0.10, 0.16], [0.17, 0.15, 0.07, 0.07, 0.15, 0.10, 0.12, 0.09, 0.08], [0.13, 0.11, 0.13, 0.03, 0.20, 0.20, 0.04, 0.15, 0.01]])

estados = [1, 2, 3, 4, 5, 6, 7, 8, 9]
rw = RandomWalk(estados, T)
estados, probs = rw.run()
print ("11 estados:", estados)
r = range(1,12)
for n in r:
  if estados[n-1] == 1:
    cont1 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 2:
    cont2 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 3:
    cont3 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 4:
    cont4 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 5:
    cont5 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 6:
    cont6 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 7:
    cont7 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 8:
    cont8 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 9:
    cont9 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)

x1 = r
y1 = c1
x2 = r
y2 = c2
x3 = r
y3 = c3
x4 = r
y4 = c4
x5 = r
y5 = c5
x6 = r
y6 = c6
x7 = r
y7 = c7
x8 = r
y8 = c8
x9 = r
y9 = c9

plt.plot(x1, y1)
plt.plot(x2, y2)
plt.plot(x3, y3)
plt.plot(x4, y4)
plt.plot(x5, y5)
plt.plot(x6, y6)
plt.plot(x7, y7)
plt.plot(x8, y8)
plt.plot(x9, y9)

plt.xlabel("Iteración del RandomWalk")
plt.ylabel("Probabilidad de Transición")
plt.title('RandomWalk Largo 10')
plt.show()
print ("-----------------------------------------------------------------------------------------")
c1=[]
c2=[]
c3=[]
c4=[]
c5=[]
c6=[]
c7=[]
c8=[]
c9=[]

cont1 = 0
cont2 = 0
cont3 = 0
cont4 = 0
cont5 = 0
cont6 = 0
cont7 = 0
cont8 = 0
cont9 = 0

estados, probs = rw.run(ntimes=100)
print ("101 estados:", estados)
r = range(1,102)
for n in r:
  if estados[n-1] == 1:
    cont1 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 2:
    cont2 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 3:
    cont3 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 4:
    cont4 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 5:
    cont5 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 6:
    cont6 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 7:
    cont7 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 8:
    cont8 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 9:
    cont9 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)

x1 = r
y1 = c1
x2 = r
y2 = c2
x3 = r
y3 = c3
x4 = r
y4 = c4
x5 = r
y5 = c5
x6 = r
y6 = c6
x7 = r
y7 = c7
x8 = r
y8 = c8
x9 = r
y9 = c9

plt.plot(x1, y1)
plt.plot(x2, y2)
plt.plot(x3, y3)
plt.plot(x4, y4)
plt.plot(x5, y5)
plt.plot(x6, y6)
plt.plot(x7, y7)
plt.plot(x8, y8)
plt.plot(x9, y9)

plt.xlabel("Iteración del RandomWalk")
plt.ylabel("Probabilidad de Transición")
plt.title('RandomWalk Largo 100')
plt.show()
print ("-----------------------------------------------------------------------------------------")
c1=[]
c2=[]
c3=[]
c4=[]
c5=[]
c6=[]
c7=[]
c8=[]
c9=[]

cont1 = 0
cont2 = 0
cont3 = 0
cont4 = 0
cont5 = 0
cont6 = 0
cont7 = 0
cont8 = 0
cont9 = 0

estados, probs = rw.run(ntimes=1000)
print ("1001 estados:", estados)
r = range(1,1002)
for n in r:
  if estados[n-1] == 1:
    cont1 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 2:
    cont2 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 3:
    cont3 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 4:
    cont4 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 5:
    cont5 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 6:
    cont6 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 7:
    cont7 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 8:
    cont8 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 9:
    cont9 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)

x1 = r
y1 = c1
x2 = r
y2 = c2
x3 = r
y3 = c3
x4 = r
y4 = c4
x5 = r
y5 = c5
x6 = r
y6 = c6
x7 = r
y7 = c7
x8 = r
y8 = c8
x9 = r
y9 = c9

plt.plot(x1, y1)
plt.plot(x2, y2)
plt.plot(x3, y3)
plt.plot(x4, y4)
plt.plot(x5, y5)
plt.plot(x6, y6)
plt.plot(x7, y7)
plt.plot(x8, y8)
plt.plot(x9, y9)

plt.xlabel("Iteración del RandomWalk")
plt.ylabel("Probabilidad de Transición")
plt.title('RandomWalk Largo 1000')
plt.show()
print ("-----------------------------------------------------------------------------------------")
c1=[]
c2=[]
c3=[]
c4=[]
c5=[]
c6=[]
c7=[]
c8=[]
c9=[]

cont1 = 0
cont2 = 0
cont3 = 0
cont4 = 0
cont5 = 0
cont6 = 0
cont7 = 0
cont8 = 0
cont9 = 0
estados, probs = rw.run(ntimes=10000)
print ("10001 estados:", estados)
r = range(1,10002)
for n in r:
  if estados[n-1] == 1:
    cont1 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 2:
    cont2 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 3:
    cont3 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 4:
    cont4 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 5:
    cont5 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 6:
    cont6 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 7:
    cont7 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 8:
    cont8 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)
  elif estados[n-1] == 9:
    cont9 += 1
    c1.append(cont1/n)
    c2.append(cont2/n)
    c3.append(cont3/n)
    c4.append(cont4/n)
    c5.append(cont5/n)
    c6.append(cont6/n)
    c7.append(cont7/n)
    c8.append(cont8/n)
    c9.append(cont9/n)

x1 = r
y1 = c1
x2 = r
y2 = c2
x3 = r
y3 = c3
x4 = r
y4 = c4
x5 = r
y5 = c5
x6 = r
y6 = c6
x7 = r
y7 = c7
x8 = r
y8 = c8
x9 = r
y9 = c9

plt.plot(x1, y1)
plt.plot(x2, y2)
plt.plot(x3, y3)
plt.plot(x4, y4)
plt.plot(x5, y5)
plt.plot(x6, y6)
plt.plot(x7, y7)
plt.plot(x8, y8)
plt.plot(x9, y9)

plt.xlabel("Iteración del RandomWalk")
plt.ylabel("Probabilidad de Transición")
plt.title('RandomWalk Largo 10000')
plt.show()
print ("-----------------------------------------------------------------------------------------")

"""Se puede notar como además de cada gráfico generado, los resultados presentan una lista con los n+1 (largo del RandomWalk + estado inicial) estados por los que se transitó en la realización de cada RandomWalk. Se puede notar además una tendencia entre los gráficos, los cuales muestran resultados similares entre sí independientemente de la cantidad de datos de cada caso.

Finalmente la parte b de la pregunta pide realizar una comparación entre los resultados obtenidos y la distribución estacionaria de Markov para el problema planteado. Para lograr esto en primera instancia se debe resolver el sistema de ecuaciones planteado en clases.

πT = π

π1 + π2 + π3 + ... + πn = 1

Tras encontrar los valores del vector π se puede generar un gráfico asociado a su distribución de probabilidad, el cual en teoría debería ser similar a los gráficos generados en el punto anterior.
"""